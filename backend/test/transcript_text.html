<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Transcription Test</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f0f8ff; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { color: #333; }
        label { display: block; margin-top: 10px; }
        input[type="text"] { width: calc(100% - 22px); padding: 10px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 10px 15px; margin-top: 15px; margin-right: 10px; border: none; border-radius: 4px; cursor: pointer; }
        .connect-btn { background-color: #5cb85c; color: white; }
        .disconnect-btn { background-color: #d9534f; color: white; }
        .record-btn { background-color: #337ab7; color: white; }
        .stop-record-btn { background-color: #f0ad4e; color: black; }
        #status { margin-top: 20px; padding: 10px; border: 1px solid #eee; border-radius: 4px; background-color: #e9ecef; }
        #transcripts { margin-top: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background-color: #f8f9fa; min-height: 100px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; }
        .log-messages { margin-top: 10px; font-size: 0.9em; color: #555; max-height: 150px; overflow-y: auto; border: 1px dashed #ddd; padding: 5px;}
    </style>
</head>
<body>
    <div class="container">
        <h1>WebSocket Transcription Test</h1>
        <p style="color: red; font-weight: bold;">
            Note: This test sends audio using browser's MediaRecorder.
            Your VAD might expect raw PCM audio. If transcription quality is poor or VAD doesn't work,
            this audio format difference could be the reason. See comments in HTML source.
            The VAD constants in your Python code (SAMPLE_RATE, etc.) suggest raw PCM.
        </p>

        <label for="sessionId">Session ID:</label>
        <input type="text" id="sessionId" value="transcribe_session_001">

        <button id="connectButton" class="connect-btn">Connect</button>
        <button id="disconnectButton" class="disconnect-btn" disabled>Disconnect</button>
        <br>
        <button id="startRecordButton" class="record-btn" disabled>Start Recording & Sending</button>
        <button id="stopRecordButton" class="stop-record-btn" disabled>Stop Recording</button>

        <div id="status">Not connected.</div>

        <h2>Transcripts:</h2>
        <div id="transcripts"></div>

        <h2>Log:</h2>
        <div id="logMessages" class="log-messages"></div>
    </div>

    <script>
        const sessionIdInput = document.getElementById('sessionId');
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const startRecordButton = document.getElementById('startRecordButton');
        const stopRecordButton = document.getElementById('stopRecordButton');
        const statusDiv = document.getElementById('status');
        const transcriptsDiv = document.getElementById('transcripts');
        const logMessagesDiv = document.getElementById('logMessages');

        let websocket = null;
        let mediaRecorder = null;
        let audioChunks = [];

        const REQUESTED_SAMPLE_RATE = 16000;
        const TIMESLICE_MS = 30;

        connectButton.onclick = () => {
            const sessionId = sessionIdInput.value.trim();
            if (!sessionId) {
                alert("Please enter a Session ID.");
                return;
            }
            // Assuming your FastAPI server runs on localhost:8000
            const wsUrl = `ws://localhost:8000/ws/${sessionId}`;

            statusDiv.textContent = `Connecting to ${wsUrl}...`;
            logInternal(`Attempting to connect to: ${wsUrl}`);
            websocket = new WebSocket(wsUrl);

            websocket.onopen = () => {
                statusDiv.textContent = `Connected to ${wsUrl}`;
                logInternal(`Successfully connected to ${wsUrl}.`);
                connectButton.disabled = true;
                disconnectButton.disabled = false;
                startRecordButton.disabled = false;
                sessionIdInput.disabled = true;
            };

            websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    logInternal(`Received JSON: ${JSON.stringify(data)}`);
                    if (data.event === 'transcript' || data.event === 'final_transcript') {
                        const p = document.createElement('p');
                        p.innerHTML = `<strong>[${data.event}]</strong> ${data.transcript} <em>(Audio bytes: ${data.audio_length_bytes || 'N/A'})</em>`;
                        transcriptsDiv.appendChild(p);
                        transcriptsDiv.scrollTop = transcriptsDiv.scrollHeight;
                    } else {
                        logInternal(`Received other event: ${data.event}`);
                    }
                } catch (e) {
                    logInternal(`Received non-JSON message or parse error: ${event.data}`);
                    console.error("Error parsing message or non-JSON message:", event.data, e);
                }
            };

            websocket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                statusDiv.textContent = "WebSocket error. See console for details.";
                logInternal(`WebSocket Error: ${error.message || 'Unknown error'}`);
                resetUI();
            };

            websocket.onclose = (event) => {
                statusDiv.textContent = `Disconnected. Code: ${event.code}, Reason: ${event.reason || 'N/A'}`;
                logInternal(`WebSocket closed. Code: ${event.code}, Reason: ${event.reason || 'N/A'}`);
                resetUI();
                 if (mediaRecorder && mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                }
            };
        };

        disconnectButton.onclick = () => {
            if (websocket) {
                websocket.close();
            }
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
        };

        startRecordButton.onclick = async () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("getUserMedia not supported on your browser!");
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: REQUESTED_SAMPLE_RATE // Request specific sample rate
                        // channelCount: 1 // Typically VAD expects mono
                    }
                });

                const track = stream.getAudioTracks()[0];
                const settings = track.getSettings();
                logInternal(`Microphone settings: SampleRate=${settings.sampleRate}, ChannelCount=${settings.channelCount}`);


                // Options for MediaRecorder. MimeType can be important.
                // Browsers often default to 'audio/webm;codecs=opus'.
                // 'audio/wav' or 'audio/pcm' are usually not supported directly by MediaRecorder.
                const options = {
                    mimeType: 'audio/webm; codecs=opus', // Common default
                    // audioBitsPerSecond: 64000, // Optional: bitrate
                    // sampleRate: REQUESTED_SAMPLE_RATE // Some browsers might support this in options
                };

                // Check if preferred mimeType is supported
                // if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                //    logInternal(`Warning: ${options.mimeType} not supported. Using default.`);
                //    delete options.mimeType; // Use browser default
                // }

                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(event.data); // event.data is a Blob
                        logInternal(`Sent audio chunk: ${event.data.size} bytes, type: ${event.data.type}`);
                    }
                };

                mediaRecorder.onstart = () => {
                    logInternal("Recording started...");
                    startRecordButton.disabled = true;
                    stopRecordButton.disabled = false;
                };

                mediaRecorder.onstop = () => {
                    logInternal("Recording stopped.");
                    startRecordButton.disabled = false;
                    stopRecordButton.disabled = true;
                    stream.getTracks().forEach(track => track.stop()); // Release microphone
                };

                mediaRecorder.start(TIMESLICE_MS); // Collect TIMESLICE_MS of audio before firing ondataavailable

            } catch (err) {
                console.error("Error accessing microphone:", err);
                logInternal(`Error accessing microphone: ${err.message}`);
                statusDiv.textContent = "Error accessing microphone.";
            }
        };

        stopRecordButton.onclick = () => {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
        };

        function logInternal(message) {
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logMessagesDiv.appendChild(p);
            logMessagesDiv.scrollTop = logMessagesDiv.scrollHeight;
        }

        function resetUI() {
            connectButton.disabled = false;
            disconnectButton.disabled = true;
            startRecordButton.disabled = true;
            stopRecordButton.disabled = true;
            sessionIdInput.disabled = false;
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            mediaRecorder = null;
        }
    </script>
</body>
</html>